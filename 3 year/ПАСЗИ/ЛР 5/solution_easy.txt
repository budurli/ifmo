1. Запускаем и пробуем ввести любой имя-ключ, получаем сообщение об ошибке в виде MessageBox.

2. Под отладчиком ищем импортируемую из библиотеки user32 функцию MessageBoxA: 
    - в OllyDebugger пкм на области дизассемблера -> Search for -> Name (label) in current module;
    - начинаем набирать название функции MessageBoxA и находим два импорта.

3a. Ставим точки останова на все вызовы MessageBoxA:
    - пкм -> Find references to import (или просто Enter на импортируемое имя) -> видим адреса с вызовами;
    - ставим точки останова на вызовы (команды CALL): пкм -> Toggle breakpoint (или F2 на вызов);
    - повторяем простановку точек останова на ещё два вызова у второго импорта.

3b. Если для OllyDebugger установлен плагин Command Line, то простановка точек останова на функцию может быть упрощена:
    - открыть командную строку Plugins -> Command Line -> Command Line (или alt+F1);
    - пишем в строку bpx MessageBoxA (команда bpx ставит точки останова на все вызовы указанной метки).

4. Запускаем выполнение программы Debug -> Run (F9) и оказываемся на том самом вызове, который показывает сообщение. В правом нижнем углу видим стек вызовов, на вершине которого находятся аргументы для функции MessageBoxA (текст, заголовок, иконка).
Более того, ниже по стеку уже видно подозрительную аски-строку, состоящую из чисел и являющуюся ключом для введённого имени. Делаем вид, что не заметили.

5. Делаем шаг без входа внутрь функции в отладчике Debug -> Step over (F8), переключаемся на программу и закрываем сообщение, переключаемся обратно в отладчик.

6. Теперь исследуем, откуда был произведён вызов данной процедуры. 
    - жмём F8 до команды возврата RET, либо Debug -> Execute till return (crtl+F9);
    - команда RET осуществляет переход на адрес на вершине стека: жмём F8 и оказываемся на 00453E04;
    - видим восстановление состояния регистров из стека и ещё один RET, осуществляем переход.

7. Здесь мы видим только что совершённый CALL процедуры с вызовом MessageBox, а несколькими строками выше заполнение заголовка и текста для мессадж бокса. Таким образом, найти это место можно было быстрее: пкм на области дизассемблера -> Search for -> All referenced text strings, затем пкм на окне с найденными строками -> Search for text 'Try another'.

8. Ещё чуть выше видим вызов процедуры с двумя аргументами, которой, как можно предположить, передавалось введённое имя для расчёта ключа. Затем вызов процедуры сравнения строк с ключами и сразу за ним условный переход JNZ (Jump-Not-Zero), прыгающий к мессаджбоксу. При отсутствии перехода мы попадём на ветку условия для правильной пары имя-ключ. 

9. Можно поставить на команду JNZ точку останова (F2) и перезапустить выполнение программы Debug -> Restart (ctrl+F2), чтобы затереть этот переход командами NOP (No-OPeration; пкм -> Binary -> Fill with NOPs), или же затереть JNZ прямо сейчас и сохранить изменения из памяти в экзешник. 

10. Сохраняем произведённые изменения в файл, потому что при перезапуске процесса все изменения, произведённые в памяти, будуь сброшены:
    - пкм -> Copy to executable -> All modifications -> Copy All;
    - пкм в открывшемся окне -> Save file -> сохраняем под другим именем;
    - открываем сохранённый файл под отладчиком.
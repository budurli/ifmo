1. Запускаем и пробуем ввести любой имя-ключ, получаем сообщение об ошибке в виде MessageBox.

2. Под отладчиком ищем импортируемую из библиотеки user32 функцию MessageBoxA: 
    - в OllyDebugger пкм на области дизассемблера -> Search for -> Name (label) in current module;
    - начинаем набирать название функции MessageBoxA и находим два импорта.

3a. Ставим точки останова на все вызовы MessageBoxA:
    - пкм -> Find references to import (или просто Enter на импортируемое имя) -> видим адреса с вызовами;
    - ставим точки останова на вызовы (команды CALL): пкм -> Toggle breakpoint (или F2 на вызов);
    - повторяем простановку точек останова на ещё два вызова у второго импорта.

3b. Если для OllyDebugger установлен плагин Command Line, то простановка точек останова на функцию может быть упрощена:
    - открыть командную строку Plugins -> Command Line -> Command Line (или alt+F1);
    - пишем в строку bpx MessageBoxA (команда bpx ставит точки останова на все вызовы указанной метки).

4. Запускаем выполнение программы Debug -> Run (F9) и оказываемся на том самом вызове, который показывает сообщение. В правом нижнем углу видим стек вызовов, на вершине
 которого находятся аргументы для функции MessageBoxA (текст, заголовок, иконка).
Более того, ниже по стеку уже видно подозрительную аски-строку, состоящую из чисел и являющуюся ключом для введённого имени. Делаем вид, что не заметили.

5. Делаем шаг без входа внутрь функции в отладчике Debug -> Step over (F8), переключаемся на программу и закрываем сообщение, переключаемся обратно в отладчик.
0019F2B4   02382608  ASCII 115767581747480


6. Теперь исследуем, откуда был произведён вызов данной процедуры. 
    - жмём F8 до команды возврата RET, либо Debug -> Execute till return (crtl+F9);
    - команда RET осуществляет переход на адрес на вершине стека: жмём F8 и оказываемся на 00453E04;
    - видим восстановление состояния регистров из стека и ещё один RET, осуществляем переход.

7. Здесь мы видим только что совершённый CALL процедуры с вызовом MessageBox, а несколькими строками выше заполнение заголовка и текста для мессадж бокса. 
Таким образом, найти это место можно было быстрее: пкм на области дизассемблера -> Search for -> All referenced text strings,
 затем пкм на окне с найденными строками -> Search for text 'Try another'.

8. Ещё чуть выше видим вызов процедуры с двумя аргументами, которой, как можно предположить, передавалось введённое имя для расчёта ключа.
Затем вызов процедуры сравнения строк с ключами и сразу за ним условный переход JNZ (Jump-Not-Zero), прыгающий к мессаджбоксу.
При отсутствии перехода мы попадём на ветку условия для правильной пары имя-ключ. 

9. Можно поставить на команду JNZ точку останова (F2) и перезапустить выполнение программы Debug -> Restart (ctrl+F2), 
чтобы затереть этот переход командами NOP (No-OPeration; пкм -> Binary -> Fill with NOPs),
 или же затереть JNZ прямо сейчас и сохранить изменения из памяти в экзешник.
 Но тогда, как мы увидим далее, при следующем запуске сработает защита, считающая
 контрольную сумму данного участка кода и произойдёт завершение процесса функцией TerminateProcess. 
Более того, защита сработает даже при наличии всего лишь брейкпоинта на этом участке кода (в частности, и на команде JNZ), 
потому что брейкпоинт является командой ассемблера int 3, вставляемой в код отладчиком, и изменяет конечную контрольную сумму.
 Этого можно избежать, если использовать Hardware breakpoint, но поскольку мы всё равно собираемся вносить изменения в код, нужно отключить проверку контрольной суммы.

10a. Перезапускаем, ставим брейкпоинт на JNZ, вводим имя-ключ, срабатывает защита. 
Сразу после самозавершения процесса смотрим в стек и ищем строку с адресом, откуда был произведён вызов 
TerminateProcess из процесса crackme, ставим на него курсор, пкм -> Follow in disassembler (или Enter).
 Оказываемся в процедуре, где происходит вызов функции подсчёта контрольной суммы и сравнения результата с константой. Если результат не совпал с константой, вызывается TerminateProcess. 

10b. Также можно было найти вызов TerminateProcess способом описанным в пунктах №2-3 (аналогично поиску MessageBoxA).

11. Выделяем вызов TerminateProcess и передаваемый ей в регистре EAX аргумент строчкой выше, пкм -> Binary -> Fill with NOPs. 
Подсчёт контрольной суммы остался, но никаких мер при её несовпадении принято не будет — не совсем красиво, но защита деактивирована. 
Можно было бы затереть ещё и вызов функции расчёта или даже все вызовы этой процедуры проверки, но сейчас это не нужно.

12. Сохраняем произведённые изменения в файл, потому что при перезапуске процесса все изменения, произведённые в памяти, будуь сброшены:
    - пкм -> Copy to executable -> All modifications -> Copy All;
    - пкм в открывшемся окне -> Save file -> сохраняем под другим именем;
    - открываем сохранённый файл под отладчиком.

13. Теперь можем вернуться к пункту №9 и затереть условный переход, после чего сохранить изменения в файл, как это было проделано в пункте №12.